### 🔶 얕은 복사와 깊은 복사

---

#### 🔸 얕은 복사
- 내용까지 아주 완벽하게 복사하는게 아니라, 주소만 복사한다는 의미에서 '얕은 복사'이다.
- 자바에서의 '대입'이 여기에 해당한다.
- 새로운 객체가 생성되는게 아니라, 원본 객체의 주소값이 새 변수에 복사된다.
- 즉, 새 변수의 메모리 상 주소는 기존 객체의 주소와 같다.
- 따라서 한 객체를 변경하면 다른 객체도 변경된다.

<br>

#### 🔸깊은 복사
- 주소가 아니라 내용물, 즉 값을 복사해온다는 의미에서 '깊은 복사'이다.
- 원본 객체의 값을 복사해서, 원본 객체로부터 독립적인 새 객체를 생성한다.
- 한 객체를 변경하더라도, 다른 객체는 영향을 받지 않는다.

<br>

### 🔶 방어적 복사

---

#### 🔸 방어적 복사란
- 객체가 외부에 의해 예상치 못한 방식으로 변경되는 것을 방지하는 기법이다.
- 외부에서 객체를 변경하더라도, 내부 객체의 변경을 막을 수 있다는 의미에서 '방어적 복사'이다.
- 생성자의 인자로 가변객체를 받아와 내부 필드를 초기화해줄 때나,
- getter 메서드로 내부 객체를 외부로 반환할 때 사용한다.

<br>

#### 🔸 방어적 복사는 깊은 복사인가?🤔
- 방어적 복사는 방법론이고, 깊은 복사는 개념이다.
- 어떤 방어적 복사를 사용하는지에 따라 깊은 복사인지, 아닌지가 달라질 수 있다.
- 단일 객체를 방어적 복사하는 경우, 기존 객체와 동일한 값을 갖는 새 객체를 만들어 방어적 복사를 할 수 있다.
- 이는 깊은 복사에 해당한다.
- 기존 객체의 주소를 참조하지 않는 독립적인 공간에, 독립적인 값을 갖기 때문이다.
- 하지만 객체를 담는 컬렉션에 대해 방어적 복사를 하는 경우, 두가지 방법을 선택할 수 있다.

<br>

1. 컬렉션 자체에 대한 복사본을 생성하는 경우
- e.g. `this.names = new ArrayList<Name>(names)` 
- 컬렉션의 주소는 공유하지 않지만, 내부 객체의 주소는 공유한다.
- 따라서, 외부의 names 에 새로운 이름이 추가되었다고 해도, 내부의 names는 변하지 않는다.
- 하지만 외부의 names 중 한 Name의 값이 변경된다면 내부 names에서 해당하는 Name의 값이 변경될 것이다.
- 즉, 이 경우 `얕은 복사`라고 볼 수 있다.

<br>

2. 내부 객체를 포장하는 새로운 객체를 만들어 컬렉션을 생성하는 경우
- e.g. `this.names = names.stream().map(Name::new).toList()`
- 이 경우 외부의 Name이 변한다고 하더라도 내부에 영향을 주지 않으므로 `깊은 복사`이다.
- 하지만 위 방법은 새로운 객체를 생성하는 비용이 든다는 단점이 있다.
- 애초에 컬렉션 안의 객체가 불변 객체라면, List.copyOf() 만으로 안전하게 만들 수 있는 것도 고려해봐야 한다.

<br>

### 🔶 방어적 복사의 방법

---

#### 🔸 Collections.unmodifiableList(existingList)
- existingList에 대한 변경 불가능한 뷰를 제공한다.
- 이 뷰를 통해 내용을 변경하려고 하면 예외가 발생한다.
- 하지만 원본 existingList 자체의 변경을 방지하지 않는다.
- 원본 existingList가 변경되면 그 변경이 뷰에도 반영된다.

➡️ existingList를 readOnly로 보고 싶을 때 사용할 수 있다. <br>
➡️ getter에서 사용하면, 외부에서 값이 변경되는것을 막을 수 있다.

<br>

#### 🔸 new ArrayList(existingList)
- existingList의 모든 요소를 포함하는 새로운 리스트를 생성한다.
- 새로운 리스트 자체는 existingList에 독립적이다.
- 하지만 내부 객체들은 같은 주소를 공유하여, 얕은 복사가 된다.
- 따라서 외부에서 existingList 내부 객체가 변경되면, 그 변경이 새로운 리스트에도 적용된다.
- 내부 객체가 불변 객체가 아닌 경우, 완전히 '방어적'이라고 보긴 어렵다.

➡️ existingList와의 관계를 끊으면서, 새로운 컬렉션을 수정하고 싶을 때 사용할 수 있다.

<br>

#### 🔸 List.copyOf(existingList)
- existingList의 불변 복사본을 생성한다.
- new ArrayList( )와 마찬가지로, 새로운 리스트 자체는 existingList에 독립적이다.
- 하지만 내부 객체들은 같은 주소를 공유하여, 얕은 복사가 된다.
- new ArrayList( )와의 차이점은, new ArrayList( )로 생성한 리스트는 수정할 수 있지만, List.copyOf( )로 생성한 점은 수정할 수 없다는 점이다.
- 복사본에 대한 제한적인 사용을 하기 위해 사용한다.

➡️ existingList와의 관계를 끊으면서, 새로운 컬렉션을 수정 방지하고 싶을 때 사용할 수 있다.

<br>

#### 🔸 정리

| 특징                               | `Collections.unmodifiableList()` | `new ArrayList()` | `List.copyOf()` |
|------------------------------------|---------------------------------------------|-------------------------------|-----------------------------|
| **기존 컬렉션의 주소 참조 여부**             |  O |  X |  X |
| **컬렉션 구조 변경 가능 여부**             | X |  O |  X                   |
| **내부 객체에 대한 얕은/깊은 복사** | 얕은 복사                                   | 얕은 복사                      | 얕은 복사                    |

<br>

#### 🔸 컬렉션에 대해 방어적 복사를 어떻게 적용할 것인가?
- 생성자에서 필드 초기화할 때
  - 리스트 자체를 불변하게 유지할 것이라면, List.copyOf()를 사용
  - 리스트에 값을 더하는 등 수정할 여지가 있자면 new ArrayList()를 사용
- getter로 내부 값을 외부로 리턴할 때
  - 기존 컬렉션의 주소를 참조하며, 리스트 구조를 불변하게 유지하게 하는 Collections.unmodifiableList()를 사용
