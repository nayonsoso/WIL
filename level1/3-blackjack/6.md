### 🔶 상태 패턴
---

![image](https://github.com/nayonsoso/WootecoTIL/assets/76177848/0c158286-7f7f-422b-8dfb-5fb32a2577a2)

<br>

#### 🔸 등장 배경

- 어플리케이션에서 객체의 상태가 바뀌며, `상태에 따라 다르게 행동`해야 하는 경우가 있다.
- 특히 게임 개발에서 자주 마주하는 상황이다.
- 이 때 객체의 필드로 상태를 둔다면, 복잡한 if문에 따라 다른 행동을 결정해야한다.
- 하지만 이런 조건문은 가독성과 유지보수성을 해친다.
- 이를 해결하기 위해 '객체가 상태에 따라 다르게 행동' 하는게 아니라, `상태가 객체의 행동을 결정짓는다`는 관점의 전환으로부터 상태 패턴이 등장하게 되었다.

<br>

#### 🔸 개념
- 상태패턴에서는 가능한 모든 상태를 클래스로 만든다.
- 그리고 상태별 행동을 해당 클래스에 모은다. 
- 이를 통해 응집도를 높이고, 유지보수성을 개선할 수 있다.

<br>

#### 🔸 구성
- 상태 인터페이스 : 모든 상태 클래스들이 따르는 행동을 정의한다.
- 구체 상태 클래스 : 상태 인터페이스를 구현하며, 각 상태에 대해 구체적인 행동을 정의한다.
- 컨텍스트 : 상태 객체를 관리하고, 행동을 상태 객체에게 위임한다. (상태 객체의 함수를 호출)
- 주의할 점은, `상태 변경의 책임을 구체 상태 클래스가 갖는다`는 점이다. 
- 이를 통해 컨텍스트의 코드가 더 간결해질 수 있다.
- 또한 상태 변경의 경계을 명시적으로 나타낼 수 있으며, 이 과정을 캡슐화 할 수 있다.

<br>

#### 🔸 상태 패턴을 적용하기 좋은 경우
- 상태의 수가 많은 경우, 각각의 상태 객체를 만드는 것이 더 유지보수하기 좋다. 
- 조건문 기반의 상태 변경이 많은 경우, 조건문을 없애 가독성을 높일 수 있다.

<br>

#### 🔸 상태 패턴을 적용하기 좋지 않은 경우
- 상태가 적은 경우, 상태 패턴을 적용하는게 과할 수 있다.
- 상태가 빈번히 바뀌는 경우, 매번 새로운 객체를 만들어야 하므로 객체 생성 비용이 늘어날 수 있다. (하지만 객체를 재사용하는 방법으로 해결할 수 있긴 하다.)

<br>

참고 : https://refactoring.guru/ko/design-patterns/state
