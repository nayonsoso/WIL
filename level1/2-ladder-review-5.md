### 🔶 생성자에는 필드 초기화 외의 다른 로직이 있어서는 안 된다 
---

#### 🔸 리뷰를 받게 된 배경
```java
class Ladder {

    private final Height height;
    private final List<Line> lines = new ArrayList<>();

    public Ladder(Height height, int playerSize, SticksGenerator sticksGenerator) {
        this.height = height;

        int stickCount = playerSize - 1;
        for (int i = 0; i < height.getHeight(); i++) {
            List<Stick> sticks = sticksGenerator.generate(stickCount);
            this.lines.add(new Line(sticks));
        }
    }
}
```
- 사다리 생성자에서 `Line` 을 만들고, for문을 반복하며 `List<Line>` 필드에 추가해주게 했다.
- 그리고 리뷰어님께 아래와 같은 피드백을 받게 되었다.
  - Ladder 안에서 Line이 생성되기 때문에, Line 생성에 실패하게 되면 Ladder 생성도 실패하게 된다.
  - 또한 Ladder 테스트 코드에서 Line의 생성 규칙을 신경써야 할 것이다.
  - 이는 강한 결합 때문에 생기는 문제라고 판단된다.
  - 문제 해결을 위해, Line 생성의 책임을 Ladder 생성자로부터 분리하면 좋겠다.
- 처음에는 어떤식의 변경을 의도하셨는지 이해하기 힘들었지만, 이내 '생성자의 책임'에 대해 공부하며 아래 규칙을 알게 되었다.

<br>

> 💡 생성자에는 필드 초기화 이외의 로직이 있으면 안된다. (검증 로직 제외)

<br>

#### 🔸 생성자에 필드 초기화 이외의 로직이 있으면 안되는 이유
- 객체의 초기화 과정이 불투명해지며, 생성 과정을 파악하기 어려워진다. 이로 인해 유지 보수가 어려워진다.
- 대부분의 개발자는 인자로 필드를 초기화할 것을 기대하기 때문에 실수를 야기할 수 있다.
- 단일 책임 원칙에 위배된다.
- 복잡한 로직은 생성 실패를 야기할 수 있다. 이때 완전히 초기화되지 않은 객체가 메모리에 남으면 문제가 발생할 수 있다.
- 생성자의 단위 테스트가 어려워진다.

<br>

#### 🔸 복잡한 생성자의 책임을 덜 수 있는 방안
- 팩토리 클래스를 사용한다.
- 정적 팩토리 메서드를 사용한다.
- 필드 초기화를 위해 필요한 로직을 생성자 외부에서 실행하고, 생성자에 결과만 주입해준다.
- 부생성자와 주생성자를 나누어 생성자 체이닝을 이용한다.

➡️ 핵심은 초기화 외의 로직을 생성자로부터 분리하는 것!

<br>

#### 🔸 개인적인 생각
- 공부를 하다 보니 더욱 생성자에는 초기화 로직만 두어야겠다고 생각하게 되었다.
- 첫째로, 더 가독성이 좋다. 여기에는 반론의 여지가 없다.
- 둘째로, 다른 개발자들이 생성자 내부를 짐작하기 쉽다.
- 마지막으로, 생성 로직이 변경되었을 때 주생성자의 내부를 바꾼다고 생각하면.. 그건 잘못된 설계 같다.
- 주생성자는 신성하게! 필드를 초기화하는 로직만 둬야겠다고 정리해본다.
