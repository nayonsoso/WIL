## 🔶 Functional Interface
---

#### 🔸 도입 배경
  - 자바에서 람다 표현식을 이용해 함수형 프로그래밍을 구현하기 위해서 도입했다.
  - 자바에서는 원래 값과 행위를 다루기 위한 기본 단위를 '객체'로 지정했다. 그것이 바로 **객체지향 프로그래밍**.
  - 하지만 **함수형 프로그래밍**에서는 함수도 값으로 취급할 수 있다.
  - 자바에서는 **람다를 통해** 함수도 일급 객체처럼 사용할 수 있게 되었다. => 유연한 개발 가능해짐
  - 함수를 일급 객체로 취급한다는 것의 의미는
    - 함수를 변수에 대입할 수 있다.
    - 함수를 다른 함수의 인자로 줄 수 있다.
    - 함수의 반환값으로 함수를 줄 수 있다.
<br>

#### 🔸 개념
  - 함수형 인터페이스는 추상 메서드가 1개만 정의된 인터페이스이다.
  - 추상 메서드가 하나만 정의되어있다는 특징 때문에, 람다 표현식을 사용할 수 있게 되었다.
  - 람다를 사용하면 괄호, 이름, 반환 타입등을 생략할 수 있으므로 코드가 간결해진다.
    - 람다 표현식을 간결하게 사용할 수 있는 이유 : 컴파일러는 람다 표현식의 시그니처(매개변수 타입, 변환 타입 등)을 함수형 인터페이스를 통해서 추론할 수 있으므로, 이를 생략할 수 있다. => 간결해짐
<br>

#### 🔸 `@FuntionalInterface` 어노테이션
  - Functional Interface라는 것을 명시하기 위해 사용한다. 
  - `@FunctionalInterface`를 사용하면 부적절한 메서드를 추가하거나 다른 인터페이스를 상속받으면 컴파일 에러가 발생한다.

<img src="https://github.com/nayonsoso/WIL/assets/76177848/513644bf-f49f-434e-a7dc-9d506c70e14d" width="500" height="300">

## 🔶 Functional Interface API
---

자바에서 제공하는 함수형 인터페이스 표준 API

#### 🔸 도입 배경
- 자바에서는 자주 사용할 것 같은 람다함수 형태를 함수형 인터페이스 표준 API로 만들어 제공해준다.
- 표준 API는 타입을 제공하는 용도이다.
  - 람다 표현식을 사용하기 위해서는 그에 해당하는 **인터페이스 타입**이 필요하다.
  - cf. 람다는 인터페이스의 구현체이고, 그 구현체를 어떤 곳에 편리하게 대입 or 반환하기 위해서 사용하므로 타입이 필요한 것은 당연하다.
  - 이때, 자바는 강타입 언어이기 때문에 타입을 명확히 지정해줘야 한다.
  - 하지만 함수형 인터페이스의 이름을 설정한다면, 아래와 같은 문제가 생길 수 있다.
    - 함수형 인터페이스를 인자로 받는 다른 함수가 있다.
    - 해당 라이브러를 사용하는 유저는 그 인터페이스의 이름을 알 방법이 없다.
    - 강타입 언어인 자바에서는 답이 없다🤯
  - 따라서 자바에서는 미리 함수형 인터페이스 이름을 정해서 제공한다.

<br>

#### 🔸 개념

| 종류             | 인자     | 반환    | 설명                                                         | 예시         |
|------------------|----------|---------|--------------------------------------------------------------|--------------|
| Runnable         |          |         | 아무 인자도 받지 않고, 반환도 없는 작업을 실행               | 스레드 실행  |
| Supplier<T>      |          | \<T>     | 값을 제공하지만, 인자는 받지 않음. 항상 같은 타입의 값을 반환 | 날짜 생성    |
| Consumer<T>      | \<T>      |         | 한 타입의 값을 소비하고, 반환하지 않음                       | 값 출력      |
| Predicate<T>     | <T>      | Boolean | 한 타입의 값이 특정 조건을 만족하는지 검사                   | 조건 검사    |
| Function<T, R>   | <T>      | <R>     | 한 타입을 받아 다른 타입으로 변환                            | 문자열을 길이로 변환 |
| UnaryOperator<T> | <T>      | <T>     | 같은 타입의 값을 받아 동일한 타입의 결과를 반환              | 숫자 두 배 증가 |
| BinaryOperator<T>| <T, T>   | <T>     | 두 같은 타입의 값을 받아 동일한 타입의 하나의 값으로 결합    | 두 수의 합   |
| BiConsumer<T, U> | <T, U>   |         | 두 다른 타입의 값을 받아 처리하고, 반환하지 않음             | 키-값 쌍 출력 |
| BiPredicate<T, U>| <T, U>   | Boolean | 두 다른 타입의 값이 특정 조건을 만족하는지 검사              | 두 조건 비교  |
| BiFunction<T, U, R>| <T, U> | <R>     | 두 다른 타입의 값을 받아, 다른 타입의 값을 반환              | 두 값의 합을 문자열로 변환 |
| Comparator<T>    | <T, T>   | int     | 두 같은 타입의 값을 비교하여 순서를 정함                     | 리스트 정렬  |

<br>

#### 🔸 람다에서의 사용

| 종류             | 람다에서의 사용                                              | 설명                                                         |
|------------------|-------------------------------------------------------------|--------------------------------------------------------------|
| Supplier<T>      | `() -> new Random().nextInt()`                               | 인자 없이 결과를 반환. 요소 생성에 사용.                     |
| Consumer<T>      | `.forEach(System.out::println)`                              | 하나의 인자를 받아서 반환값 없이 처리. 출력에 사용.          |
| Predicate<T>     | `.filter(x -> x > 0)`                                        | 하나의 인자를 받아 boolean 값을 반환. 필터링 연산에 사용.    |
| Function<T, R>   | `.map(x -> x.toString())`                                    | 하나의 인자를 받아 결과를 반환. 입력과 출력 타입이 다름.    |
| UnaryOperator<T> | `.map(String::toUpperCase)`                                  | 하나의 인자를 받아 동일한 타입의 결과를 반환. 변형에 사용.   |
| BinaryOperator<T>| `.reduce(0, Integer::sum)`                                   | 동일한 타입의 두 인자를 받아 하나의 결과를 반환. 스트림의 요소들을 합치기에 사용. |
| BiConsumer<T, U> | `(k, v) -> System.out.println("Key: " + k + ", Value: " + v)`| 두 인자를 받아서 반환값 없이 처리. 두 요소의 소비에 사용.    |


## 🔶 정적 팩토링 메소드의 네이밍 규칙
---
#### 🔸 내용
- 정적 팩토리 메서드(Static Factory Method) 패턴은 개발자가 구성한 Static Method를 통해 간접적으로 생성자를 호출하는 객체를 생성하는 디자인 패턴이다. 
출처: https://inpa.tistory.com/entry/GOF-💠-정적-팩토리-메서드-생성자-대신-사용하자 [Inpa Dev 👨‍💻:티스토리]
