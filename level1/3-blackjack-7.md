### 🔶 전략 패턴
---

![image](https://github.com/nayonsoso/WootecoTIL/assets/76177848/bea5d330-69b5-40f7-b506-f51eb1197863)

<br>

#### 🔸 등장 배경
- 어떠한 '행동'에 대해, 큰 의미는 같지만 일부 방식에 차이가 있을 때가 있다.
- 예를 들어, 자동차 게임에서 자동차는 이동한다.
- 하지만 어떻게 이동할지는 조금씩 달라진다. e.g. 랜덤하게 이동, 한칸씩 이동
- 자동차의 이동 방법이 바뀔 때마다 자동차 코드를 수정한다면 유지보수가 힘들 것이다.
- 이런 상황에서 행동을 캡슐화하고, 변경을 매끄럽게 하기 위해 전략 패턴이 등장하게 되었다.

<br>

#### 🔸 구성
- 전략 인터페이스 : 컨텍스트가 전략을 실행하는데 사용하는 메서드를 선언한다.
- 구체 전략 클래스 : 전략의 다양한 변형을 구현한다.
- 컨텍스트 : 전략 인터페이스를 필드로 둔다. 작업의 실행을 위해 전략 객체의 메서드를 호출한다. 
- 컨텍스트 외부 : 생성자나 setter를 사용하여 컨텍스트의 전략을 지정한다. 
- 컨텍스트는 작업의 실행을 전략 객체에 맡기고, 동작이 어떻게 실행되는지와 자신이 어떤 전략을 사용하는지 모른다.

<br>

#### 🔸 전략 패턴의 장점
- 런타임 시점에서 전략을 바꿀 수 있다.
- 컨텍스트 클래스의 코드를 줄인다.
- 행동을 캡슐화하며, 교체하기에 용이하다.
- 테스트가 안되는 전략을 다른 것으로 교체함으로써, 테스트를 쉽게 할 수 있다.

<br>

#### 🔸 전략 패턴과 상태 패턴의 비교

- 두 디자인 패턴 모두 조합을 사용했기 때문에 구조가 비슷하다고 느낄 수 있지만, 의도가 다르다.
- 전략 패턴은 '행동'을 전략으로 추상화한 것이고,
- 상태 패턴은 '상태에 따른 행동'과 '상태 변환'을 상태로 추상화한 것이다.

> 상태는 전략의 확장으로 간주할 수 있습니다. 두 패턴 모두 합성을 기반으로 합니다. 그들은 어떤 작업을 도우미 객체들에 전달하여 콘텍스트의 행동을 바꿉니다. 전략 패턴은 이러한 객체들을 완전히 독립적으로 만들어 서로를 인식하지 못하도록 만듭니다. 그러나 상태는 구상 상태들 사이의 의존 관계들을 제한하지 않으므로 그들이 콘텍스트의 상태를 마음대로 변경할 수 있도록 합니다.

<br>

참고 : https://refactoring.guru/ko/design-patterns/strategy
